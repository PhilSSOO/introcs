//1.4.20 Modify SelfAvoidingWalk (program 1.4.4) to calculate and
// print the average length of the paths as well as the dead-end
// probability. Keep separate the
//        average lengths of escape paths and dead-end paths.

public class EX1420 {
    public static void main(String[] args) {
        // Do trials random self-avoiding
        // walks in an n-by-n lattice.
        int n = 25; // Integer.parseInt(args[0]);
        int trials = 10000; // Integer.parseInt(args[1]);
        int deadEnds = 0;
        boolean dead = false;

        int totalEscape = 0;
        int totalDeadend = 0;

        for (int t = 0; t < trials; t++) {
            boolean[][] a = new boolean[n][n];
            // start frm centr
            int x = n/2, y = n/2;
            int count = 0;
            while (x > 0 && x < n-1 && y > 0 && y < n-1)
            { // Check for dead end and make a random move.
                a[x][y] = true;
                count++;
                if (a[x-1][y] && a[x+1][y] && a[x][y-1] && a[x][y+1])
                {
                    deadEnds++;
                    totalDeadend += count; // ???
                    dead = true;
                    break;
                }
                double r = Math.random();
                if (r < 0.25) { if (!a[x+1][y]) x++; }
                else if (r < 0.50) { if (!a[x-1][y]) x--; }
                else if (r < 0.75) { if (!a[x][y+1]) y++; }
                else if (r < 1.00) { if (!a[x][y-1]) y--; }
            }
            // when we get here, either dead or escap
            if (dead) {
                dead = false; // reset dead to start a new trial
            }
            else {
                totalEscape += count;
                dead = false;
            }
        }

        System.out.println(100*deadEnds/trials + "% dead ends");
        System.out.println((double)totalEscape/trials + " len esc path");
        System.out.println((double)totalDeadend/trials + " len dead end path");
    }
}
