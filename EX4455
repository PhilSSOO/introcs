package a44ST;
//4.4.55 Order statistics. Add to BST a method select() that takes
// an integer argument k and returns the kth smallest key in the
// BST. Maintain subtree sizes in each
//        node (see exercise 4.4.29). The running time should be
//        proportional to the height
//        of the tree.
public class EX4455 {
}

//Program 4.4.4 Binary search tree
class BST55<Key extends Comparable<Key>, Value>
{
    private Node root;
    // chk if a key is already in the tree
    private boolean keyAgain;
    private class Node
    {
        Key key;
        Value val;
        int nNODESinLeftSubtree;
        Node left, right;
        Node(Key key, Value val)
        {
            this.key = key;
            this.val = val;
            nNODESinLeftSubtree = 1;
        }
    }

    public Key select(int k)
    {
        return select(k, root);
    }

    private Key select(int k, Node nd)//, int count)//, Queue<Key> queue)
    {
        if (nd == null) {
            return null;
        }
// If k is smaller than the number of elements in the left subtree,
// the kth smallest element must belong to the left subtree
        if (nd.nNODESinLeftSubtree > k) {
           // System.out.println("in left of " + nd.key);
            return select(k, nd.left);
        }
        else if (nd.nNODESinLeftSubtree == k) {
            return nd.key;
        }
        else {// nd.nNODESinLeftSubtree < k
            return select(k - nd.nNODESinLeftSubtree, nd.right);
        }
    }

    public Value get(Key key)
    { return get(root, key); }
    private Value get(Node x, Key key)
    {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp < 0) return get(x.left, key);
        else if (cmp > 0) return get(x.right, key);
        else return x.val;
    }
    public void put(Key key, Value val)
    { root = put(root, key, val); }

    private Node put(Node x, Key key, Value val)
    {
        if (x == null) {
            Node node = new Node(key, val);
            return node;
        }
        int cmp = key.compareTo(x.key);
        if (cmp < 0) {
            if (get(key) != null)
                keyAgain = true;
            // new key
            if (keyAgain != true) {
                x.nNODESinLeftSubtree++;
            }
            else
                keyAgain = false; // set back to false for following judgement
            x.left = put(x.left, key, val);
        }
        else if (cmp > 0) {
            x.right = put(x.right, key, val);
        }
        else x.val = val;
        return x;
    }

    public static void main(String[] args) {
        BST55 bst55 = new BST55();
        bst55.put("9", 11);
        bst55.put("4", 11);
        bst55.put("3", 11);
        bst55.put("1", 11);
        bst55.put("7", 11);
        bst55.put("0", 11);
        bst55.put("3", 22); // 3 twice
        bst55.put("8", 11);
        bst55.put("6", 11);
        int k = 4;
        System.out.println("k "+k);
        String ss = (String)bst55.select(k);
        System.out.println(ss);
    }
}

