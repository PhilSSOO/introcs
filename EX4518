////4.5.18 Write a program that plots average path length versus the number
//// of random edges as random shortcuts are added to a 2-ring graph on 1,000
//// vertices.
package a45;

import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Comparator;

public class EX4518a {
    private int n;
    // when no shortct, each vtx can only access other vtx via circum
    // we hv a circle, top vtx is say vtx 0, bott 500 (so tot 1000)
    // i = 0 to 998 (clockws), j = 1 to 999, j>i (so 1 pair is only
    // counted once)

    public EX4518a(int nVertices) {
        n = nVertices;
    }
    // to weed out a pair tht is same as an existing one
    private boolean isDff(int[][] arr, int ran1, int ran2, int curr) {
        for (int i = 0; i < curr; i++) { // i <= curr??????
            if (arr[i][0] == ran1 && arr[i][1] == ran2)
                return false;
        }
        return true;
    }

    // find all edges within (i,j) and calc the path length
    private int lenIJ(int[][] randEdges, int i, int j, int index) {
        int nEd = randEdges.length;
        // qualified edge Start
        int qualifiedEdge = 0;
        // if edg not confined in ij
        while ((randEdges[qualifiedEdge][0] < i ||
                randEdges[qualifiedEdge][1] > j)) {
            qualifiedEdge++;
            if (qualifiedEdge == nEd) {
                break;
            }
        }

        if (qualifiedEdge == nEd) {
            return pathLenViaCircle(i,j);
        }
        return pathLenViaCircle(i, randEdges[qualifiedEdge][0]) + 1 +
                lenIJ(randEdges, randEdges[qualifiedEdge][1], j,
                        qualifiedEdge+1);
    }

    private int[][] randomEdgesGenerator(int nRanE) {
        int[][] randomEdges = new int[nRanE][2];
        int i = 0;
        int ran1, ran2;
        while (i < nRanE) {
            ran1 = StdRandom.uniform(n);
            ran2 = StdRandom.uniform(n);
            if (ran2 -  ran1 > 2 && isDff(randomEdges, ran1, ran2, i))
                randomEdges[i++] = new int[]{ran1,ran2};
        }
        sortbyColumn(randomEdges, 0);
        return randomEdges;
    }

    // Function to sort by column, frm
    //https://www.geeksforgeeks.org/sorting-2d-array-according-values-given-column-java/
    private static void sortbyColumn(int arr[][], int col)
    {
        // Using built-in sort function Arrays.sort
        Arrays.sort(arr, new Comparator<int[]>() {
            @Override
            // Compare values according to columns
            public int compare(final int[] entry1,
                               final int[] entry2) {
                // To sort in descending order revert
                // the '>' Operator
                if (entry1[col] > entry2[col])
                    return 1;
                else
                    return -1;
            }
        });
    }

    private int pathLenViaCircle(int i, int j) {
        int jmi = j - i;
        if(jmi > n/2) {
            jmi = n - jmi;
        }
        return (jmi/2 + jmi%2);
    }

    public static void main(String[] args) {
        int n = 100;
        int nRanEd = 4;
        EX4518a ex4518 = new EX4518a(n);
        int[][] randEdges = ex4518.randomEdgesGenerator(nRanEd);
        int start = 11;
        int end = 91;
        int startToEnd = ex4518.lenIJ(randEdges, start, end, 0);
        System.out.println(startToEnd);
    }
}

class Graph18
{
    private ST<String, SET<String>> st;
    public Graph18()
    { st = new ST<String, SET<String>>(); }
    public void addEdge(String v, String w)
    { // Put v in w’s SET and w in v’s SET.
        if (!st.contains(v)) st.put(v, new SET<String>());
        if (!st.contains(w)) st.put(w, new SET<String>());
        st.get(v).add(w);
        st.get(w).add(v);
    }
    public Iterable<String> adjacentTo(String v)
    { return st.get(v); }
    public Iterable<String> vertices()
    { return st.keys(); }
}
