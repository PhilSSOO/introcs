//4.3.19 Develop a data type ResizingArrayQueueOfStrings that implements a
//        queue with a fixed-length array in such a way that all operations
//        take constant time.
//        Then, extend your implementation to use a resizing array to
//        remove the length restriction. Hint: The challenge is that the
//        items will “crawl across” the array as items
//        are added to and removed from the queue. Use modular arithmetic
//        to maintain the
//        array indices of the items at the front and back of the queue

public class EX4319 {

}

class FixedSizeArrayQueueOfStrings {
    private int start;// first slot with a str
    private int end; // first slot empty
    private String[] aa;

    public FixedSizeArrayQueueOfStrings(int sz) {
        start = 0;
        end = 0;
        aa = new String[sz];
    }
    public boolean isEmpty()
    { return (end == start && aa[start] == null); }

    public void enqueue(String item) throws Exception {
        if (end == start && aa[start] != null) {
            throw new Exception("qu is full");
        }
        aa[end] = item;
        end = (end+1)%aa.length;
    }

    public String dequeue() throws Exception { // Remove the first
        if (isEmpty())
            throw new Exception("qu is emp");
        String item = aa[start];
        aa[start] = null;
        start = (start+1)%aa.length;
        return item;
    }

    public static void main(String[] args) throws Exception {
        FixedSizeArrayQueueOfStrings ff = new FixedSizeArrayQueueOfStrings(4);
        // ff.dequeue();
        ff.enqueue("a");
        ff.enqueue("a1");
        ff.enqueue("a2");
        ff.enqueue("a3");
        System.out.println(ff.dequeue());
        ff.enqueue("a4");
        System.out.println(ff.dequeue());
        ff.enqueue("a5");
        System.out.println(ff.dequeue());
        for (int i = 0; i < 4; i++) {
            System.out.println(ff.aa[i]);
        }
    }
}

class ResizingArrayQueueOfStrings1 {
    private int n = 0;// nums of items
    private int start;// fst slot with a str
    private int end; // fst slot emp
    private String[] items = new String[1];

    // refer p579 Program 4.3.3 Stack of strings (resizing array)
    private void resize(int capacity)
    {
        String[] temp = new String[capacity];
        for (int i = start; i < end; i++) {
            temp[i-start] = items[i];
        }
        int endminusstart = end - start;
        start = 0;
        end = endminusstart;
        items = temp;
    }

    public boolean isEmpty()
    { return (n == 0); }

    public void enque(String item) throws Exception {
        if (n == items.length) {
            resize(2*items.length);
        }
        items[end] = item;
        end++;
        n++;
    }

    public String deque() throws Exception { // Remove the first
        if (isEmpty())
            return null;
        String item = items[start];
        items[start] = null;
        start++;
        n--;
        if (n > 0 && n == items.length/4) resize(items.length/2);
        return item;
    }

    public static void main(String[] args) throws Exception {
        ResizingArrayQueueOfStrings1 rr = new ResizingArrayQueueOfStrings1();
        // to be or not to - be - - that
        while (!StdIn.isEmpty()) {
            String ss = StdIn.readString();
            if (ss.equals("-")) {
                System.out.println(rr.deque());
            }
            else
                rr.enque(ss);
            for (int i = 0; i < rr.items.length; i++) {
                System.out.print(rr.items[i] + " ");
            }
            System.out.println();
        }
    }
}

